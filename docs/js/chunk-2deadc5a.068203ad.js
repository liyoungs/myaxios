(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["chunk-2deadc5a"],{5045:function(e,t,r){"use strict";var o=r("fa0d"),s=r.n(o);s.a},"823a":function(e,t,r){"use strict";r.r(t);var o=function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("div",{staticStyle:{position:"relative"}},[r("h2",[e._v("Pomise ҈")]),r("img",{staticClass:"preloadImage",attrs:{src:e.keyUrl,alt:"Promise preloadImage loadImgAsyc"}}),r("el-alert",{attrs:{type:"error",closable:!1,effect:"dark"}},[r("ul",{attrs:{slot:"title"},slot:"title"},[r("li",[e._v(" ES6 规定，Promise 对象是一个构造函数，用来生成 Promise 实例。Promise 构造函数接受一个 "),r("i",{staticStyle:{color:"#303133"}},[e._v("函数")]),e._v(" 作为参数，该函数的两个参数分别是 resolve 和 reject 。 ")]),r("li",[e._v(" resolve 函数的作用是，将 Promise 对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去； ")]),r("li",[e._v(" reject 函数的作用是 ，将 Promise 对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。 ")]),r("li",[e._v(" Promise 实例生成以后，可以用 then 方法分别指定 resolved 状态和 rejected 状态的回调函数。promise.then(function(value) { /* success */ }, function(error) { /* failure */ }); ")]),r("li",[e._v(" then方法可以接受两个回调函数作为参数。第一个回调函数是Promise对象的状态变为resolved时调用，第二个回调函数是Promise对象的状态变为rejected时调用。其中，第二个函数是可选的，不一定要提供。这两个函数都接受Promise对象传出的值作为参数。 ")]),r("li",[e._v(" Promise 实例具有then方法，也就是说，then方法是定义在原型对象Promise.prototype上的。它的作用是为 Promise 实例添加状态改变时的回调函数。前面说过，then方法的第一个参数是resolved状态的回调函数，第二个参数（可选）是rejected状态的回调函数。 then方法返回的是一个新的Promise实例（注意，不是原来那个Promise实例）。因此可以采用链式写法，即then方法后面再调用另一个then方法。 ")]),r("li",[e._v(" Promise.prototype.catch方法是.then(null, rejection)或.then(undefined, rejection)的别名，用于指定发生错误时的回调函数。 ")]),r("li",[e._v(" 不管Promise实例最后的状态，在执行完then或catch指定的回调函数以后，都会执行finally方法指定的回调函数。 ")])])]),r("el-card",{staticStyle:{width:"720px",margin:"auto"}},[r("el-tag",{attrs:{slot:"header"},slot:"header"},[e._v("实例1 ====> 分析")]),r("el-tag",{staticClass:"code-wrap",attrs:{type:"danger"}},[e._v(" const PROMISE = new Promise((resolve, reject) => { "),r("br"),e._v(" console.log(1); "),r("br"),e._v(" resolve(2); "),r("br"),e._v(" console.log(3); "),r("br"),e._v(" }); "),r("br"),e._v(" PROMISE.then(value => { "),r("br"),e._v(' console.log("then" + value); '),r("br"),e._v(" }).catch(error => { "),r("br"),e._v(' console.log("error" + error); '),r("br"),e._v(" }); "),r("br"),e._v(" console.log(4); ")]),r("el-tag",{staticClass:"code-define",staticStyle:{width:"360px"},attrs:{type:"danger"}},[e._v(" 本例新建一个 Promise 实例🍐对象 ==> PROMISE ，用 then 、catch 方法分别指定 resolved 状态和 rejected 状态的回调函数。运行结果：1,3,4,then2; 这是因为 Promise 是一个容器，里面有 resolve 和 reject 两个异步事件，在 PROMISE 执行之后，控制台输出1,3,4。resolve执行的结果有then承接为then2。 ")])],1),r("el-card",{staticStyle:{width:"720px",margin:"auto"}},[r("el-tag",{attrs:{slot:"header"},slot:"header"},[e._v("实例2 ====> 分析")]),r("el-tag",{staticClass:"code-wrap",attrs:{type:"danger"}},[e._v(" setTimeout(function () { "),r("br"),e._v(" console.log('three'); "),r("br"),e._v(" }, 0); "),r("br"),r("br"),e._v(" Promise.resolve().then(function () { "),r("br"),e._v(" console.log('two'); "),r("br"),e._v(" }); "),r("br"),r("br"),e._v(" console.log('one'); "),r("br"),r("br"),e._v(" // one "),r("br"),e._v(" // two "),r("br"),e._v(" // three ")]),r("el-tag",{staticClass:"code-define",attrs:{type:"danger"}},[e._v(" 代码中， setTimeout(fn, 0) 在下一轮 “事件循环” 开始时执行， Promise.resolve() 在本轮 “事件循环” 结束时执行，console.log('one') 则是立即执行，因此最先输出。 ")])],1),r("el-card",{staticStyle:{width:"720px",margin:"auto"}},[r("el-tag",{attrs:{slot:"header"},slot:"header"},[e._v("Generator 函数的解构赋值")]),r("img",{staticStyle:{width:"680px",height:"216px"},attrs:{src:e.yieldUrl,alt:"function* yield"}}),r("el-tag",{staticStyle:{"white-space":"normal",width:"680px",height:"auto"},attrs:{type:"danger"}},[e._v(" Generator 函数是分段执行的，每次返回遍历器对象，直到遇到一个 yield 表达式（或 return 语句）为止，遍历器对象自带 next 方法。本例中为 fibs 做一个数组的解构赋值，也就是说，首先为 first 赋值，执行到 yield a; 为止，first =>a =>0。再为 second 赋值，也就是执行 next 方法。而每次调用 next 方法， 内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个 yield 表达式（或 return 语句）为止。 换言之，为 second 赋值先执行 [a, b] = [b, a + b];即 a =>b =>1。 也就是 second=>a =>1。以此类推。 ")])],1)],1)},s=[],n=(r("d3b7"),{name:"JsBaseHigher3",data:function(){return{keyUrl:r("cf05"),yieldUrl:r("a514")}},methods:{loadImgAsyc:function(e){return new Promise((function(t,r){var o=new Image;o.onload=t,o.onerror=r,o.src=e}))},handlePromiseAjax:function(e){var t=new Promise((function(t,r){var o=function(e){4===e.readyState&&(200===e.status?t(e.response):r(new Error(e.statusText)))},s=new XMLHttpRequest;s.onreadystatechange=o,s.open("get",e),s.send(null)}));return t}},mounted:function(){var e=this;this.loadImgAsyc("https://images.sftcdn.net/images/t_app-logo-l,f_auto,dpr_auto/p/449d6486-96d2-11e6-b4e2-00163ec9f5fa/2631397628/microsoft-edge-edge%20icon.png").then((function(t){console.log(t),e.keyUrl=t.path[0].src})).catch((function(e){console.log(e)})),console.log(" /* eslint-disable no-undef, no-unused-expressions */")}}),a=n,l=(r("5045"),r("2877")),i=Object(l["a"])(a,o,s,!1,null,null,null);t["default"]=i.exports},a514:function(e,t,r){e.exports=r.p+"img/yield.7a45a3f9.png"},fa0d:function(e,t,r){}}]);
//# sourceMappingURL=chunk-2deadc5a.068203ad.js.map